---
layout: post
title: "IPC - Memory Mapped Files"
date: 2024-03-14
categories: os
---

In the previous article, [Shared Memory](https://goodyduru.github.io/os/2024/01/31/ipc-shared-memory.html) IPC mechanism was discussed. In this article, I will write about a similar IPC mechanism called Memory Mapped Files.

In order to fully understand, you'd need to understand virtual memory which I talked about in the Shared Memory article. Let's talk about how mmap IPC works

### Memory Mapped IPC
When processes need to communicate with each other via mmap, they use a file as the channel for message transfer. Here's how:

* Each process opens the file using the `open()` function call. This creates the file object in the kernel and returns a file descriptor number which will be used to reference the file object.

* The processes call the [`mmap()`](https://man7.org/linux/man-pages/man2/mmap.2.html) function which accepts a starting address, the size, some protection flags, flags (the MAP_SHARED bits must be set for IPC), the file descriptor number from the `open()` call and starting byte offset. The kernel creates the pages in each processes's page table whose total size is the specified size in the `mmap()` function call. Initially, these pages are not mapped to any physical address. An virtual address to the starting page is returned which could be the `starting address` argument or an address chosen by the OS.

* When the processes initially try to access (read/write) the address returned by the `mmap` call, a page-fault occurs. This page fault happens because the virtual address hasn't been mapped to a physical address. To fix this, the kernel does the mapping. When it begins the mapping process, it sees that the page's virtual address is linked to a file. The kernel checks its [Page Cache](https://github.com/firmianay/Life-long-Learner/blob/master/linux-kernel-development/chapter-16.md) to search for the file page. If it finds the file page, the kernel maps the virtual address to the physical address of the file page in the processes' page tables. If the file page isn't found in the Page Cache, the file segment associated with the page is loaded into the Page Cache and mapping is done. Once mapping is done, the processes' are resumed by the OS and the address access instruction is re-executed. This results in a situation where all the various processes' virtual pages are mapped to the *same* physical pages. This step doesn't need to happen simultaneously in the processes. 

* When a process writes to an address within the mmaped pages, the data is written to the mapped pages in the Page Cache. Since all the other communicating processes have those same pages mmaped into their page tables, they can read that data from that address whether or not the data is flushed to disk. Squint, and it's like the processes are communicating via a memory buffer mapped into their page tables. Reading and writing to these mmapped addresses is no different from reading and writing to an internal address.

* Unmapping the file is done via the [`munmap()`](https://man7.org/linux/man-pages/man2/mmap.2.html). This removes the mapped pages from the calling process's page table.

Enough theory, let's dive into code.

### Show me the code
Our example will demonstrate two Python processes communicating via mmap, a server and a client. The client will send a "ping" message to the server, and the server will print it out.

Here's the client

```python
import mmap
import os
import time

ROUNDS = 100
FILE_SIZE = 20


def run():
    path = '/tmp/example'
    fd = os.open(path, flags=os.O_CREAT|os.O_RDWR)
    os.lseek(fd, FILE_SIZE, os.SEEK_SET)
    os.write(fd, b" ")
    os.lseek(fd, 0, os.SEEK_SET)
    mem = mmap.mmap(fd, FILE_SIZE)
    i = 0
    message = b"ping"
    while i != ROUNDS:
        mem.write(message)
        print("Client: Sent ping")
        mem.seek(0)
        data = mem.read(4)
        while data == message:
            time.sleep(1e-6)
            mem.seek(0)
            data = mem.read(4)
        data = data.decode()
        print(f"Client: Received {data}")
        mem.seek(0)
        i += 1
    mem.write(b"end")
    mem.close()
    os.close(fd)


run()
```

A temp file is (optionally) created to ensure that it exists. A byte is written to the end of the file to ensure that the file size must be as large as the mmaped memory. The file is then mmaped into the client's page table which returns an Python mmap object.. A loop is run where a message containing a byte string is sent. To prevent the process from processing a message that it sent, a while loop runs that puts the process to sleep and receives a message. The while loop stops if the message differs from the one sent, signifying that the message was sent from another process. This while loop is a very primitive form of communication synchronization. The message received is decoded and printed, and then the loop continues. The loop is ended when _ROUNDS_ messages are sent. Afterward, an _end_ message is sent to signify that the client is done.

The file's current position is always reset to the beginning after every read and write. This is because the position is always updated to the point after the bytes that were read or written. The program resets this position because it wants to read or write to/from the start of the mmaped address.

Messages sent and received are byte strings, not regular strings, and thus have to be encoded and decoded accordingly.

Here's the server code

```python
import mmap
import os
import time

FILE_SIZE = 20

def run():
    path = '/tmp/example'
    fd = os.open(path, flags=os.O_CREAT|os.O_RDWR) # create file
    os.lseek(fd, FILE_SIZE, os.SEEK_SET)
    os.write(fd, b" ")
    os.lseek(fd, 0, os.SEEK_SET)
    mem = mmap.mmap(fd, FILE_SIZE)
    data = mem.read(4)
    mem.seek(0)
    message = b"pong"
    while data != b"ping":
        time.sleep(5e-6)
        data = mem.read(4)
        mem.seek(0)
    data = data.decode()
    while data[0] != 'e':
        print(f"Server: Received {data}")
        mem.write(message)
        print(f"Server: Sent pong")
        mem.seek(0)
        data = mem.read(4)
        while data == message:
            time.sleep(1e-6)
            mem.seek(0)
            data = mem.read(4)
        data = data.decode()
        mem.seek(0)
    mem.close()
    os.close(fd)
    os.unlink(path)


run()
```

The server code sets up the mmap pages similarly to the client code. A message is sent and a while loop runs that ensures the message received isn't the same as the sent message. A loop is run, which checks that the first character of the received message isn't equal to _e_ which signifies that _end_ wasn't received. Inside this loop, the received message is printed, and a different message is sent. Once sent, another message check runs as a while loop. The message is then received and decoded.

The loop stops once the _end_ message is received. The file used for mmap is deleted. The program then exits.

Note that the file position is reset just like in the client's code.

### Performance
Memory-mapped file is super fast. It is the fastest IPC mechanism in the [IPC-Bench](https://github.com/goldsborough/ipc-bench#benchmarked-on-intelr-coretm-i5-4590s-cpu--300ghz-running-ubuntu-20041-lts) benchmark tests. Its throughput was 1,701,759 msg 1KB messages per second on an Intel(R) Core(TM) i5-4590S CPU @ 3.00GHz running Ubuntu 20.04.1 LTS. That's super fast.

Its speed is what made Cloudflare [switch](https://blog.cloudflare.com/scalable-machine-learning-at-cloudflare) from Unix Sockets to it in their machine learning service

Due to its blazing-fast speed and its similarity to the standard reading and writing to memory addresses, you'd need to include some form of synchronization mechanism when using mmap files just as the code snippets above show.

### Demo Code
You can find my code that demonstrates mmap files on [GitHub](https://github.com/goodyduru/ipc-demos).

### Conclusion
Memory-mapped files are a very fast and versatile IPC mechanism. The only caveat is that synchronisation has to be included for effective and robust communication. Get this right, and its worth it.

This brings me to the conclusion of my series on Inter-process communication. Hope you enjoyed them? Thanks for reading. Take care of yourself and stay hydrated! ‚úåüèæ